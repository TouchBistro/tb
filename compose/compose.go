package compose

import (
	"io"
	"strings"

	"github.com/TouchBistro/tb/service"
	"github.com/pkg/errors"
	"gopkg.in/yaml.v3"
)

type composeBuild struct {
	Args    map[string]string `yaml:"args,omitempty"`
	Context string            `yaml:"context,omitempty"`
	Target  string            `yaml:"target,omitempty"`
}

type composeService struct {
	Build         composeBuild      `yaml:"build,omitempty"` // non-remote
	Command       string            `yaml:"command,omitempty"`
	ContainerName string            `yaml:"container_name"`
	DependsOn     []string          `yaml:"depends_on,omitempty"`
	Entrypoint    []string          `yaml:"entrypoint,omitempty"`
	EnvFile       []string          `yaml:"env_file,omitempty"`
	Environment   map[string]string `yaml:"environment,omitempty"`
	Image         string            `yaml:"image,omitempty"` // remote
	Ports         []string          `yaml:"ports,omitempty"`
	Volumes       []string          `yaml:"volumes,omitempty"`
}

type composeFile struct {
	Version  string                    `yaml:"version"`
	Services map[string]composeService `yaml:"services"`
	Volumes  map[string]interface{}    `yaml:"volumes,omitempty"`
}

func createComposeService(s service.Service) composeService {
	cs := composeService{
		ContainerName: s.DockerName(),
		DependsOn:     s.Dependencies,
		Entrypoint:    s.Entrypoint,
		EnvFile:       []string{},
		Environment:   s.EnvVars,
		Ports:         s.Ports,
	}

	if s.EnvFile != "" {
		cs.EnvFile = append(cs.EnvFile, s.EnvFile)
	}

	var volumes []service.Volume
	if s.UseRemote() {
		cs.Command = s.Remote.Command
		cs.Image = s.ImageURI()
		volumes = s.Remote.Volumes
	} else {
		cs.Build = composeBuild{
			Args:    s.Build.Args,
			Context: s.Build.DockerfilePath,
			Target:  s.Build.Target,
		}

		cs.Command = s.Build.Command
		volumes = s.Build.Volumes
	}

	for _, v := range volumes {
		cs.Volumes = append(cs.Volumes, v.Value)
	}

	return cs
}

func CreateComposeFile(services *service.ServiceCollection, w io.Writer) error {
	composeServices := make(map[string]composeService)
	// Top level named volumes are an empty field, i.e. `postgres:`
	// There's no way to create an empty field with go-yaml
	// so we use interface{} and set it to nil which produces `postgres: null`
	// docker-compose seems cool with this
	composeVolumes := make(map[string]interface{})

	it := services.Iter()
	for it.HasNext() {
		s := it.Next()

		name := s.DockerName()
		composeServices[name] = createComposeService(s)

		// Add named volumes
		var volumes []service.Volume
		if s.UseRemote() {
			volumes = s.Remote.Volumes
		} else {
			volumes = s.Build.Volumes
		}
		for _, v := range volumes {
			if !v.IsNamed {
				continue
			}

			namedVolume := strings.Split(v.Value, ":")[0]
			composeVolumes[namedVolume] = nil
		}
	}

	composeFile := composeFile{
		Version:  "3.7",
		Services: composeServices,
		Volumes:  composeVolumes,
	}

	_, err := w.Write([]byte("# THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY\n\n"))
	if err != nil {
		return errors.Wrap(err, "failed to write header comment to docker-compose yaml file")
	}

	err = yaml.NewEncoder(w).Encode(&composeFile)
	return errors.Wrap(err, "failed to encode docker-compose struct to yaml")
}
